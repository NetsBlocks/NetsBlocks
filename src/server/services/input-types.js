// handles the incoming input arguments for the RPCs. Parses and validates the inputs based on the code docs for the functions
const _ = require('lodash');
const blocks2js = require('./blocks2js');
const Projects = require('../storage/projects');

const GENERIC_ERROR = new Error('');  // don't add to the error msg generated by rpc-manager

const NB_TYPES = {
    Array: 'List',
    Object: 'Structured Data',
    BoundedNumber: 'Number',
    BoundedString: 'Input',
};

// converts a javascript type name into netsblox type name
function getNBType(jsType) {
    return NB_TYPES[jsType] || jsType;
}

const types = {};

types.Number = input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    }
    return input;
};

types.BoundedNumber = (input, params) => {
    const [min, max] = params.map(num => parseInt(num));
    const number = types.Number(input);
    if (isNaN(max)) {  // only minimum specified
        if (number < min) {
            throw new Error(`Number must be greater than ${min}`);
        }
        return number;
    }

    if (isNaN(min)) {  // only maximum specified
        if (max < number) {
            throw new Error(`Number must be less than ${max}`);
        }
        return number;
    }

    if (number < min || max < number) {  // both min and max bounds
        throw new Error(`Number must be between ${min} and ${max}`);
    }
    return number;
};


types.BoundedString = (input, params) => {
    const [min, max] = params.map(num => parseInt(num));
    const inString = input.toString();

    if(max == min)
    {
        if (inString.length != min) {
            throw new Error(`Length must be ${min}`);
        }
        return inString;
    }

    if (isNaN(max)) {  // only minimum specified
        if (inString.length < min) {
            throw new Error(`Length must be greater than ${min}`);
        }
        return inString;
    }


    if (isNaN(min)) {  // only maximum specified
        if (max < inString.length) {
            throw new Error(`Length must be less than ${max}`);
        }
        return inString;
    }

    if (inString.length < min || max < inString.length) {  // both min and max bounds
        throw new Error(`Length must be between ${min} and ${max}`);
    }
    return inString;
};


types.Date = input => {
    input = new Date(input);
    if (isNaN(input.valueOf())) {
        throw GENERIC_ERROR;
    }
    return input;
};

types.Array = (input, params) => {
    const [innerType] = params;
    if (!Array.isArray(input)) throw GENERIC_ERROR;
    if (innerType) {
        input = input.map(value => types[innerType](value));
    }
    return input;
};

types.Latitude = input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    } else if (input < -90 || input > 90) {
        throw new Error('Latitude must be between -90 and 90.');
    }
    return input;
};

types.Longitude = input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    } else if (input < -180 || input > 180) {
        throw new Error('Longitude must be between -180 and 180.');
    }
    return input;
};

// all Object types are going to be structured data (simplified json for snap environment)
types.Object = input => {
    // check if it has the form of structured data
    let isArray = Array.isArray(input);
    if (!isArray || !input.every(pair => pair.length === 2 || pair.length === 1)) {
        throw new Error('It should be a list of (key, value) pairs.');
    }
    input = _.fromPairs(input);
    return input;
};

types.Function = async (blockXml, _params, ctx) => {
    let roleName = '';
    let roleNames = [''];

    if (ctx) {
        const metadata = await Projects.getProjectMetadataById(ctx.caller.projectId);
        if (metadata) {
            roleNames = Object.values(metadata.roles)
                .map(role => role.ProjectName);
            roleName = metadata.roles[ctx.caller.roleId].ProjectName;
        }
    }

    let factory = blocks2js.compile(blockXml);
    let env = blocks2js.newContext();
    env.__start = function(project) {
        project.ctx = ctx;
        project.roleName = roleName;
        project.roleNames = roleNames;
    };
    const fn = await factory(env);
    const {doYield} = env;
    return function() {
        env.doYield = doYield.bind(null, Date.now());
        return fn.apply(this, arguments);
    };
};

function _enumError(id, variants) {
    if (variants.length <= 10) throw Error(`Unknown ${id}: should be ${variants.join(', ')}`);
    else throw Error(`Unknown ${id}: should be ${variants.slice(0, 10).join(', ')}, ...`);
}
types.Enum = (input, params) => {
    const [id, variants] = params;
    const lower = input.toString().toLowerCase();

    if (Array.isArray(variants)) { // passing an array just checks that it is a valid variant and returns the variant
        for (const variant of variants) {
            if (lower === variant.toLowerCase()) return variant;
        }
        _enumError(id, variants); // this throws
    }
    else { // passing an object checks for validity and maps to the given value
        for (const variant in variants) {
            if (lower === variant.toLowerCase()) return variants[variant];
        }
        _enumError(id, Object.keys(variants)); // this throws
    }
};

types.Bool = input => types.Enum(input, ['Bool', { 'true': true, 'false': false }]);

types.String = input => input.toString();
types.Any = input => input;

const SERVICE_TYPES = {};
const WAITING_TYPES = {};
function defineForService(service, serviceTypes) {
    const lower = service.toLowerCase();
    if (SERVICE_TYPES[lower] !== undefined) throw Error(`input-types: types for service ${sevice} were already defined`);
    SERVICE_TYPES[lower] = serviceTypes;

    // resolve any waiters
    const waiters = WAITING_TYPES[lower];
    if (waiters !== undefined) {
        delete WAITING_TYPES[lower];
        for (const resolve of waiters) resolve(serviceTypes);
    }
}
async function forService(service) {
    return new Promise((resolve) => {
        const lower = service.toLowerCase();
        const res = SERVICE_TYPES[lower];
        if (res !== undefined) resolve(res); // if it's already defined, we have the value
        else { // otherwise wait for it to be defined
            let waiters = WAITING_TYPES[lower];
            if (waiters === undefined) waiters = (WAITING_TYPES[lower] = []);
            waiters.push(resolve);
        }
    });
}

module.exports = {
    parse: types,
    getNBType,
    defineForService,
    forService,
};
