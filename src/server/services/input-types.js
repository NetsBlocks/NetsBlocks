// handles the incoming input arguments for the RPCs. Parses and validates the inputs based on the code docs for the functions
const _ = require('lodash');
const blocks2js = require('./blocks2js');
const Projects = require('../storage/projects');

const GENERIC_ERROR = new Error('');  // don't add to the error msg generated by rpc-manager

const NB_TYPES = {
    Array: 'List',
    Object: 'Structured Data',
    BoundedNumber: 'Number',
};
// converts a javascript type name into netsblox type name
function getNBType(jsType) {
    return NB_TYPES[jsType] || jsType;
}

class InputTypeError extends Error { }
class ParameterError extends InputTypeError { }
class EnumError extends ParameterError {
    constructor(name, variants) {
        const message = name ? `${name} must be one of ${variants.join(', ')}` :
            `It must be one of ${variants.join(', ')}`;
        super(message);
    }
}

function getErrorMessage(arg, err) {
    const typeName = arg.type.name;
    const netsbloxType = getNBType(typeName);
    const omitTypeName = err instanceof ParameterError ||
        err.message.includes(netsbloxType);
    const msg = omitTypeName ? 
        `"${arg.name}" is not valid.` :
        `"${arg.name}" is not a valid ${netsbloxType}.`;

    if (err.message) {
        return msg + ' ' + err.message;
    } else {
        return msg;
    }
}

// Any is the only first-order type, and it has no base type
const types = { Any: input => input };
const baseTypes = { Any: { name: null } };

function getTypeParser(type) {
    if (!type) return undefined;

    const t = types[type];
    if (t) return t;

    const t2 = types[type.name]; // alias so we don't repeat lookups on every call of closure
    return input => t2(input, type.params);
}

function defineType(name, parser, baseType) {
    if (types[name]) throw Error(`Defining duplicate type: ${name}`);
    if (!baseType) throw Error('Base type is required for complete type info. If the new type is truly stand-alone, you can use \'Any\' as the base type');
    if (typeof(baseType) === 'string') baseType = { name: baseType };
    if (!baseTypes[baseType.name]) throw Error(`Base type ${baseType.name} does not exist`);

    types[name] = parser;
    baseTypes[name] = baseType;
    return parser;
}

defineType('String', input => input.toString(), 'Any');

defineType('Enum', (input, variants, _ctx, name) => {
    const lower = input.toString().toLowerCase();
    const variantDict = Array.isArray(variants) ?
        _.fromPairs(variants.map(name => [name, name])) :
        variants;

    for (const variant in variantDict) {
        if (lower === variant.toLowerCase()) return variantDict[variant];
    }

    throw new EnumError(name, Object.keys(variantDict));
}, 'String');

function defineEnum(name, variants) {
    const parser = input => types.Enum(input, variants, undefined, name);
    const variantOptions = Array.isArray(variants) ? variants : Object.keys(variants);
    const baseType = { name: 'Enum', params: variantOptions };
    return defineType(name, parser, baseType);
}

defineEnum('Boolean', {'true': true, 'false': false});

defineType('Number', input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    }
    return input;
}, 'Any');

defineType('Array', async (input, params=[]) => {
    const [typeParam, min=0, max=Infinity] = params;
    const innerType = getTypeParser(typeParam);

    if (!Array.isArray(input)) throw new InputTypeError();
    if (innerType) {
        let i = 0;
        try {
            for (; i < input.length; ++i) input[i] = await innerType(input[i]);
        }
        catch (e) {
            throw new ParameterError(`Item ${i+1} ${e}`);
        }
    }
    if (min === max && input.length !== min) throw new ParameterError(`List must contain ${min} items`);
    if (input.length < min) throw new ParameterError(`List must contain at least ${min} items`);
    if (input.length > max) throw new ParameterError(`List must contain at most ${max} items`);
    return input;
}, 'Any');

// all Object types are going to be structured data (simplified json for snap environment)
defineType('Object', async (input, params=[], ctx) => {
    // check if it has the form of structured data
    let isArray = Array.isArray(input);
    if (!isArray || !input.every(pair => pair.length === 2 || pair.length === 1)) {
        throw new InputTypeError('It should be a list of (key, value) pairs.');
    }
    input = _.fromPairs(input);
    if (!params.length) return input; // no params means we accept anything, so return raw input as obj

    const res = {};
    for (const param of params) {
        const value = input[param.name];
        delete input[param.name];
        const isMissingField = value === undefined || value === null;

        if (isMissingField) {
            if (param.optional) continue;
            throw new ParameterError(`It must contain a(n) ${param.name} field`);
        }

        try {
            res[param.name] = await types[param.type.name](value, param.type.params, ctx);
        } catch(err) {
            throw new ParameterError(`Field ${getErrorMessage(param, err)}`);
        }
    }

    const extraFields = Object.keys(input);
    if (extraFields.length) {
        throw new ParameterError(`It contains extra fields: ${extraFields.join(', ')}`);
    }
    return res;
}, 'Any'); // arguably base type is Array, but that's only for NetsBlox itself (not e.g. the python service wrapper)

defineType('Function', async (blockXml, _params, ctx) => {
    let roleName = '';
    let roleNames = [''];

    if (ctx) {
        const metadata = await Projects.getProjectMetadataById(ctx.caller.projectId);
        if (metadata) {
            roleNames = Object.values(metadata.roles)
                .map(role => role.ProjectName);
            roleName = metadata.roles[ctx.caller.roleId].ProjectName;
        }
    }

    let factory = blocks2js.compile(blockXml);
    let env = blocks2js.newContext();
    env.__start = function(project) {
        project.ctx = ctx;
        project.roleName = roleName;
        project.roleNames = roleNames;
    };
    const fn = await factory(env);
    const {doYield} = env;
    return function() {
        env.doYield = doYield.bind(null, Date.now());
        return fn.apply(this, arguments);
    };
}, 'Any');

defineType('SerializedFunction', async (blockXml, _params, ctx) => {
    await types.Function(blockXml, _params, ctx);  // check that it compiles
    return blockXml;
}, 'Function');

defineType('BoundedNumber', (input, params) => {
    const [min, max] = params.map(num => parseInt(num));
    const number = types.Number(input);
    if (isNaN(max)) {  // only minimum specified
        if (number < min) {
            throw new ParameterError(`Number must be greater than ${min}`);
        }
        return number;
    }

    if (isNaN(min)) {  // only maximum specified
        if (max < number) {
            throw new ParameterError(`Number must be less than ${max}`);
        }
        return number;
    }

    if (number < min || max < number) {  // both min and max bounds
        throw new ParameterError(`Number must be between ${min} and ${max}`);
    }
    return number;
}, 'Number');

defineType('BoundedString', (input, params) => {
    const [min, max] = params.map(num => parseInt(num));
    const inString = input.toString();

    if(max == min)
    {
        if (inString.length != min) {
            throw new ParameterError(`Length must be ${min}`);
        }
        return inString;
    }

    if (isNaN(max)) {  // only minimum specified
        if (inString.length < min) {
            throw new ParameterError(`Length must be greater than ${min}`);
        }
        return inString;
    }


    if (isNaN(min)) {  // only maximum specified
        if (max < inString.length) {
            throw new ParameterError(`Length must be less than ${max}`);
        }
        return inString;
    }

    if (inString.length < min || max < inString.length) {  // both min and max bounds
        throw new ParameterError(`Length must be between ${min} and ${max}`);
    }
    return inString;
}, 'String');

defineType('Date', input => {
    input = new Date(input);
    if (isNaN(input.valueOf())) {
        throw GENERIC_ERROR;
    }
    return input;
}, 'String');

defineType('Latitude', input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    } else if (input < -90 || input > 90) {
        throw new InputTypeError('Latitude must be between -90 and 90.');
    }
    return input;
}, 'BoundedNumber'); // we don't actually refer to BoundedNumber, but only because it'd give a different error message

defineType('Longitude', input => {
    input = parseFloat(input);
    if (isNaN(input)) {
        throw GENERIC_ERROR;
    } else if (input < -180 || input > 180) {
        throw new InputTypeError('Longitude must be between -180 and 180.');
    }
    return input; 
}, 'BoundedNumber'); // we don't actually refer to BoundedNumber, but only because it'd give a different error message

module.exports = {
    parse: types,
    getNBType,
    defineType,
    defineEnum,
    baseTypes,
    getErrorMessage,
    Errors: {
        ParameterError,
        InputTypeError,
    }
};
